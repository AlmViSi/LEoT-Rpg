<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/common.css">
    <title>Grimoire: Spell Constructor</title>
</head>
<style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Roboto', sans-serif;
            background-color: #0A0A0A;
            color: #D9E4DD;
            overflow-x: hidden;
        }
        
        #particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        header {
            background: rgba(26, 38, 57, 0.8);
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid #00A3E0;
        }
        
        header h1 {
            margin: 0;
            font-family: 'Cinzel', serif;
            color: #D9E4DD;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 1rem;
            background: rgba(26, 38, 57, 0.8);
            border: 1px solid #00A3E0;
            border-radius: 5px;
            position: relative;
            z-index: 5;
        }
        
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 1rem;
            position: relative;
            z-index: 10;
        }
        
        .tab {
            padding: 0.5rem 1rem;
            background: #1A2639;
            color: #D9E4DD;
            border: 1px solid #00A3E0;
            cursor: pointer;
            font-family: 'Cinzel', serif;
            transition: all 0.3s ease;
        }
        
        .tab:first-child {
            border-radius: 5px 0 0 5px;
        }
        
        .tab:last-child {
            border-radius: 0 5px 5px 0;
        }
        
        .tab.active {
            background: #00A3E0;
            color: #0A0A0A;
            font-weight: bold;
        }
        
        .tab:hover:not(.active) {
            background: rgba(0, 163, 224, 0.3);
        }
        
        .tab-content {
            display: none;
            animation: fadeIn 0.5s ease;
            padding: 1rem;
            background: rgba(10, 10, 10, 0.5);
            border: 1px solid #00A3E0;
            border-radius: 5px;
            margin-top: 1rem;
        }
        
        .tab-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        label {
            display: block;
            margin: 10px 0 5px;
            font-family: 'Cinzel', serif;
            color: #D9E4DD;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            background: rgba(26, 38, 57, 0.8);
            border: 1px solid #00A3E0;
            color: #D9E4DD;
            font-family: 'Roboto', sans-serif;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        
        input:focus, select:focus, textarea:focus {
            border-color: #00A3E0;
            outline: none;
            box-shadow: 0 0 8px rgba(0, 163, 224, 0.5);
        }
        
        button {
            padding: 10px 20px;
            background: #00A3E0;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Cinzel', serif;
			font-weight: bold;
			font-size: 1.2em;
            transition: all 0.3s ease;
        }
        
        button:hover {
            background: #D9E4DD;
        }
        
        .list-manager, .spell-list {
            margin-top: 20px;
        }
        
        .list-item {
            margin-bottom: 8px;
            padding: 8px;
            background: rgba(26, 38, 57, 0.8);
            border: 1px solid #00A3E0;
            border-radius: 5px;
            animation: fadeIn 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .spell-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .spell-table th, .spell-table td {
            border: 1px solid #00A3E0;
            padding: 8px;
            text-align: left;
        }
        
        .spell-table th {
            background: rgba(26, 38, 57, 0.8);
            font-family: 'Cinzel', serif;
            color: #00A3E0;
        }
        
        .spell-table tr:hover {
            background: rgba(0, 163, 224, 0.1);
        }
        
        .filter-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .autocomplete {
            position: relative;
            flex-grow: 1;
        }
        
        .autocomplete-list {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(26, 38, 57, 0.9);
            border: 1px solid #00A3E0;
            border-radius: 5px;
            max-height: 150px;
            overflow-y: auto;
            z-index: 10;
            animation: fadeIn 0.2s ease;
        }
        
        .autocomplete-item {
            padding: 8px;
            cursor: pointer;
            transition: background 0.2s ease;
        }
        
        .autocomplete-item:hover {
            background: rgba(0, 163, 224, 0.2);
        }
        
        .language-switcher {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 10;
        }
        
        .language-switcher button {
            padding: 8px 16px;
            font-size: 0.9em;
        }
        
        .list-manager .input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .list-manager .input-group input, 
        .list-manager .input-group select {
            flex: 1;
			color: white;
			font-size: 1.2em;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 100;
            align-items: center;
            justify-content: center;
        }
        
        .modal-content {
            background: rgba(26, 38, 57, 0.9);
            border: 2px solid #00A3E0;
            border-radius: 8px;
            padding: 20px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            animation: fadeIn 0.3s ease;
        }
        
        .modal-content h3 {
            font-family: 'Cinzel', serif;
            color: #00A3E0;
            text-align: center;
            margin-bottom: 20px;
        }
        
        .modal-content table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .modal-content th, .modal-content td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #00A3E0;
        }
        
        .modal-content th {
            font-family: 'Cinzel', serif;
            color: #00A3E0;
            width: 40%;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .dynamic-input-group {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .dynamic-input-group input, 
        .dynamic-input-group select {
            flex-grow: 1;
            margin-bottom: 0;
        }
        
        .removing {
            animation: fadeOut 0.3s ease forwards;
        }
.tooltip-spell {
    position: fixed; /* Меняем на fixed для точного позиционирования */
    z-index: 1000;
    width: 800px;
    max-height: 70vh;
    overflow-y: auto;
    background: rgba(26, 38, 57, 0.98);
    border: 2px solid #00A3E0;
    border-radius: 8px;
    padding: 20px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    box-shadow: 0 0 20px rgba(0, 163, 224, 0.7);
    display: grid;
    grid-template-columns: 1fr 2fr; /* Правая часть в 2 раза шире */
    gap: 20px;
    transform: translate(-50%, 10px); /* Центрируем по горизонтали и смещаем вниз */
}

.tooltip-spell h4 {
    margin: 0 0 15px 0;
    color: #ffd700;
    font-family: 'Cinzel', serif;
    text-align: center;
    grid-column: 1 / -1;
    font-size: 1.2em;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(0, 163, 224, 0.5);
}

.tooltip-description {
    grid-column: 1;
    padding: 15px;
    background: rgba(10, 15, 25, 0.6);
    border: 1px solid rgba(0, 163, 224, 0.3);
    border-radius: 6px;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
}

.tooltip-attributes {
    grid-column: 2;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 12px;
    padding: 15px;
    background: rgba(10, 15, 25, 0.6);
    border: 1px solid rgba(0, 163, 224, 0.3);
    border-radius: 6px;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
}

.tooltip-section {
    margin-bottom: 20px;
}

.tooltip-section h5 {
    margin: 0 0 8px 0;
    color: #00A3E0;
    font-family: 'Cinzel', serif;
    font-size: 0.95em;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.tooltip-section p {
    margin: 0;
    font-size: 0.95em;
    line-height: 1.5;
    color: #D9E4DD;
}

.tooltip-attribute {
    display: flex;
    margin-bottom: 8px;
    padding: 5px;
    background: rgba(26, 38, 57, 0.5);
    border-radius: 4px;
    border-left: 3px solid #00A3E0;
    align-items: center; /* Выравниваем по центру по вертикали */
}

.tooltip-label {
    font-weight: bold;
    color: #00A3E0;
    margin-right: 5px; /* Уменьшаем отступ */
    font-family: 'Cinzel', serif;
    font-size: 0.85em;
    white-space: nowrap;
}

.tooltip-value {
    font-size: 0.9em;
    color: #D9E4DD;
    word-break: break-word;
    margin-left: 0; /* Убираем отступ */
}

        
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 0.5rem;
            }
            
            .tabs {
                flex-wrap: wrap;
            }
            
            .tab {
                flex: 1 0 auto;
                margin-bottom: 5px;
                border-radius: 5px !important;
            }
            
            .filter-container {
                flex-direction: column;
            }
}
</style>
<body>
    <canvas id="particle-canvas"></canvas>
    <header>
        <h1>Lost Edge of Time - Traits Selection</h1>
    </header>
    
    <div class="tab-container">
        <a href="index.html" class="tab">Origin</a>
        <a href="race.html" class="tab">Race</a>
        <a href="traits.html" class="tab active">Traits</a>
        <a href="powersets.html" class="tab">Power Sets</a>
        <a href="character.html" class="tab">Character</a>
    </div>

    <div class="language-switcher">
        <button onclick="switchLanguage('en')">English</button>
        <button onclick="switchLanguage('ru')">Русский</button>
    </div>
    <div class="container">
        <h1 id="title" style="font-family: 'Cinzel', serif; text-align: center; color: #ffd700; text-shadow: 0 0 10px #ffd700;"></h1>
        <div class="tabs" id="tabs">
            <div class="tab active" data-tab="spell-creator" draggable="true" onclick="showTab('spell-creator')" id="tab-creator"></div>
            <div class="tab" data-tab="spell-list" draggable="true" onclick="showTab('spell-list')" id="tab-list"></div>
            <div class="tab" data-tab="list-manager" draggable="true" onclick="showTab('list-manager')" id="tab-manager"></div>
        </div>

        <div id="spell-creator" class="tab-content active">
            <h2 id="creator-title"></h2>
            <form id="spell-form">
                <label for="spell-name" class="tooltip" id="label-spell-name"></label>
                <input type="text" id="spell-name" placeholder="">

                <label for="spell-type-container" class="tooltip" id="label-spell-type"></label>
                <div id="spell-type-container">
                    </div>

                <label for="power-set-container" class="tooltip" id="label-power-set"></label>
                <div id="power-set-container">
                    </div>

                <label for="power-set-tree-container" class="tooltip" id="label-power-set-tree"></label>
                <div id="power-set-tree-container">
                    </div>

                <label for="level-container" class="tooltip" id="label-level"></label>
                <div id="level-container">
                    </div>

                <label for="description" class="tooltip" id="label-description"></label>
                <textarea id="description" rows="4" placeholder=""></textarea>

                <label for="action-container" class="tooltip" id="label-action"></label>
                <div id="action-container">
                    </div>

                <label for="target-container" class="tooltip" id="label-target"></label>
                <div id="target-container">
                    </div>

                <label for="range-container" class="tooltip" id="label-range"></label>
                <div id="range-container">
                    </div>

                <label for="duration-container" class="tooltip" id="label-duration"></label>
                <div id="duration-container">
                    </div>

                <label for="effect" class="tooltip" id="label-effect"></label>
                <textarea id="effect" rows="4" placeholder=""></textarea>

                <label for="cooldown-container" class="tooltip" id="label-cooldown"></label>
                <div id="cooldown-container">
                    </div>

                <label for="cost-container" class="tooltip" id="label-cost"></label>
                <div id="cost-container">
                    </div>

                <label for="defense-container" class="tooltip" id="label-defense"></label>
                <div id="defense-container">
                    </div>

                <label for="attack-container" class="tooltip" id="label-attack"></label>
                <div id="attack-container">
                    </div>

                <label for="restrictions-container" class="tooltip" id="label-restrictions"></label>
                <div id="restrictions-container">
                    </div>

                <label for="upgrades-container" class="tooltip" id="label-upgrades"></label>
                <div id="upgrades-container">
                    </div>

                <div class="button-group">
                    <button type="button" onclick="saveSpell()" id="save-spell" class="tooltip" data-tooltip="Ctrl+S"></button>
                    <button type="button" onclick="loadSpell()" id="load-spell" class="tooltip" data-tooltip="Ctrl+L"></button>
                    <button type="button" onclick="clearForm()" id="clear-form" class="tooltip" data-tooltip="Ctrl+R"></button>
                </div>
            </form>
        </div>
		
		<div id="spell-tooltip" class="tooltip-spell"></div>

        <div id="spell-list" class="tab-content">
            <h2 id="list-title"></h2>
            <div class="filter-container">
                <div class="autocomplete">
                    <input type="text" id="filter-name" placeholder="" oninput="updateAutocomplete()">
                    <div id="autocomplete-list" class="autocomplete-list" style="display: none;"></div>
                </div>
                <select id="filter-power-set" onchange="updateFilterPowerSetTree()"></select>
                <select id="filter-power-set-tree"></select>
                <select id="filter-type"></select>
            </div>
            <table class="spell-table">
                <thead>
                    <tr>
                        <th id="table-name"></th>
                        <th id="table-power-set"></th>
                        <th id="table-power-set-tree"></th>
                        <th id="table-type"></th>
                        <th id="table-action"></th>
                    </tr>
                </thead>
                <tbody id="spell-table-body"></tbody>
            </table>
        </div>

        <div id="list-manager" class="tab-content">
            <h2 id="manager-title"></h2>
            <div class="list-manager">
                <label for="manager-list-type" id="label-manager-list-type">Select List to Manage:</label>
                <select id="manager-list-type" onchange="showManagedList()">
                    <option value="">-- Select --</option>
                    <option value="type">Type</option>
                    <option value="powerSets">Power Set & Tree</option>
                    <option value="action">Action</option>
                    <option value="target">Target</option>
                    <option value="range">Range/Radius</option>
                    <option value="duration">Duration</option>
                    <option value="cooldown">Cooldown</option>
                    <option value="cost">Cost</option>
                    <option value="defense">Defense</option>
                    <option value="attack">Attack</option>
                </select>

                <div id="manager-type-section" style="display: none;">
                    <h3 id="manager-type"></h3>
                    <div class="input-group">
                        <input type="text" id="new-type" placeholder="">
                        <button onclick="addListItem('type', 'new-type')" id="add-type"></button>
                    </div>
                    <div id="type-list"></div>
                </div>

                <div id="manager-powerSets-section" style="display: none;">
                    <h3 id="manager-power-set"></h3>
                    <div class="input-group">
                        <input type="text" id="new-power-set" placeholder="">
                        <button onclick="addPowerSet()" id="add-power-set"></button>
                    </div>
                    <div id="power-set-list"></div>

                    <h3 id="manager-power-set-tree"></h3>
                    <label for="power-set-select" id="label-power-set-select"></label>
                    <div class="input-group">
                        <select id="power-set-select" onchange="loadPowerSetTreeForEdit()"></select>
                        <input type="text" id="new-power-set-tree" placeholder="">
                        <button onclick="addPowerSetTree()" id="add-power-set-tree"></button>
                    </div>
                    <div id="power-set-tree-list"></div>
                </div>

                <div id="manager-action-section" style="display: none;">
                    <h3 id="manager-action"></h3>
                    <div class="input-group">
                        <input type="text" id="new-action" placeholder="">
                        <button onclick="addListItem('action', 'new-action')" id="add-action"></button>
                    </div>
                    <div id="action-list"></div>
                </div>

                <div id="manager-target-section" style="display: none;">
                    <h3 id="manager-target"></h3>
                    <div class="input-group">
                        <input type="text" id="new-target" placeholder="">
                        <button onclick="addListItem('target', 'new-target')" id="add-target"></button>
                    </div>
                    <div id="target-list"></div>
                </div>

                <div id="manager-range-section" style="display: none;">
                    <h3 id="manager-range"></h3>
                    <div class="input-group">
                        <input type="text" id="new-range" placeholder="">
                        <button onclick="addListItem('range', 'new-range')" id="add-range"></button>
                    </div>
                    <div id="range-list"></div>
                </div>

                <div id="manager-duration-section" style="display: none;">
                    <h3 id="manager-duration"></h3>
                    <div class="input-group">
                        <input type="text" id="new-duration" placeholder="">
                        <button onclick="addListItem('duration', 'new-duration')" id="add-duration"></button>
                    </div>
                    <div id="duration-list"></div>
                </div>

                <div id="manager-cooldown-section" style="display: none;">
                    <h3 id="manager-cooldown"></h3>
                    <div class="input-group">
                        <input type="text" id="new-cooldown" placeholder="">
                        <button onclick="addListItem('cooldown', 'new-cooldown')" id="add-cooldown"></button>
                    </div>
                    <div id="cooldown-list"></div>
                </div>

                <div id="manager-cost-section" style="display: none;">
                    <h3 id="manager-cost"></h3>
                    <div class="input-group">
                        <input type="text" id="new-cost" placeholder="">
                        <button onclick="addListItem('cost', 'new-cost')" id="add-cost"></button>
                    </div>
                    <div id="cost-list"></div>
                </div>

                <div id="manager-defense-section" style="display: none;">
                    <h3 id="manager-defense"></h3>
                    <div class="input-group">
                        <input type="text" id="new-defense" placeholder="">
                        <button onclick="addListItem('defense', 'new-defense')" id="add-defense"></button>
                    </div>
                    <div id="defense-list"></div>
                </div>

                <div id="manager-attack-section" style="display: none;">
                    <h3 id="manager-attack"></h3>
                    <div class="input-group">
                        <input type="text" id="new-attack" placeholder="">
                        <button onclick="addListItem('attack', 'new-attack')" id="add-attack"></button>
                    </div>
                    <div id="attack-list"></div>
                </div>


                <div class="data-controls">
                    <button onclick="exportData()" class="tooltip" data-tooltip="Export all data to JSON file" id="export-data"></button>
                    <input type="file" id="import-data-file" accept=".json" style="display: none;" onchange="importData(event)">
                    <button onclick="document.getElementById('import-data-file').click()" class="tooltip" data-tooltip="Import data from JSON file" id="import-data"></button>
                </div>
            </div>
        </div>

        <div id="spell-modal" class="modal">
            <div id="modal-content" class="modal-content"></div>
        </div>
    </div>

    <script>
        // Language data
        const translations = {
            en: {
                title: "Grimoire: Spell Constructor",
                tab_creator: "Spell Creator",
                tab_list: "Spell List",
                tab_manager: "List Manager",
                creator_title: "Create a Spell",
                label_spell_name: "Spell Name",
                tooltip_spell_name: "Enter a unique name for your spell",
                placeholder_spell_name: "Enter spell name",
                label_spell_type: "Type",
                tooltip_spell_type: "Select the type of spell",
                label_power_set: "Power Set",
                tooltip_power_set: "Choose the main category of the spell",
                label_power_set_tree: "Power Set Tree",
                tooltip_power_set_tree: "Select the specific subcategory",
                label_level: "Level/Rank/Requirements",
                tooltip_level: "Specify level or requirements",
                placeholder_level: "e.g., 5th level, Rank 3",
                label_description: "Description",
                tooltip_description: "Describe the spell's narrative effect",
                placeholder_description: "Describe the spell's effect",
                label_action: "Action",
                tooltip_action: "Type of action required to cast",
                label_target: "Target",
                tooltip_target: "Who or what the spell affects",
                label_range: "Range/Radius",
                tooltip_range: "Range or radius of the spell",
                label_duration: "Duration",
                tooltip_duration: "How long the spell lasts",
                label_effect: "Effect",
                tooltip_effect: "Mechanical effect of the spell",
                placeholder_effect: "e.g., Deals 4d6 fire damage",
                label_cooldown: "Cooldown",
                tooltip_cooldown: "Time before spell can be used again",
                label_cost: "Cost",
                tooltip_cost: "Resources required to cast the spell",
                label_defense: "Defense",
                tooltip_defense: "Defensive attributes affecting the spell",
                label_attack: "Attack",
                tooltip_attack: "Attack attributes enhancing the spell",
                label_restrictions: "Restrictions/Conditions",
                tooltip_restrictions: "Limitations of the spell",
                placeholder_restrictions: "e.g., Requires line of sight",
                label_upgrades: "Variants/Upgrades",
                tooltip_upgrades: "Possible upgrades or variants",
                placeholder_upgrades: "e.g., Radius increases at level 10",
                save_spell: "Save Spell",
                load_spell: "Load Last Spell",
                clear_form: "Clear Form",
                list_title: "Spell List",
                placeholder_filter_name: "Filter by Name",
                table_name: "Name",
                table_power_set: "Power Set",
                table_power_set_tree: "Power Set Tree",
                table_type: "Type",
                table_action: "Action",
                delete_spell: "Delete",
                edit_spell: "Edit",
                close_modal: "Close",
                modal_title: "Spell Details",
                confirm_delete: "Are you sure you want to delete this spell?",
                confirm_delete_title: "Confirm Deletion",
                confirm: "Confirm",
                cancel: "Cancel",
                manager_title: "Manage Dropdown Lists",
                label_manager_list_type: "Select List to Manage:",
                manager_type: "Type List",
                placeholder_new_type: "Add new Type",
                add_type: "Add",
                manager_power_set: "Power Set List",
                placeholder_new_power_set: "Add new Power Set",
                add_power_set: "Add",
                manager_power_set_tree: "Power Set Tree List",
                label_power_set_select: "Select Power Set",
                placeholder_new_power_set_tree: "Add new Power Set Tree",
                add_power_set_tree: "Add",
                manager_action: "Action List",
                placeholder_new_action: "Add new Action",
                add_action: "Add",
                manager_target: "Target List",
                placeholder_new_target: "Add new Target",
                add_target: "Add",
                manager_range: "Range/Radius List",
                placeholder_new_range: "Add new Range/Radius",
                add_range: "Add",
                manager_duration: "Duration List",
                placeholder_new_duration: "Add new Duration",
                add_duration: "Add",
                manager_cooldown: "Cooldown List",
                placeholder_new_cooldown: "Add new Cooldown",
                add_cooldown: "Add",
                manager_cost: "Cost List",
                placeholder_new_cost: "Add new Cost",
                add_cost: "Add",
                manager_defense: "Defense List",
                placeholder_new_defense: "Add new Defense",
                add_defense: "Add",
                manager_attack: "Attack List",
                placeholder_new_attack: "Add new Attack",
                add_attack: "Add",
                export_data: "Export Data",
                import_data: "Import Data",
                remove_button: "-", // Changed to generic remove symbol
                add_button: "+"    // Changed to generic add symbol
            },
            ru: {
                title: "Гримуар: Конструктор заклинаний",
                tab_creator: "Создание заклинаний",
                tab_list: "Список заклинаний",
                tab_manager: "Управление списками",
                creator_title: "Создать заклинание",
                label_spell_name: "Название заклинания",
                tooltip_spell_name: "Введите уникальное название заклинания",
                placeholder_spell_name: "Введите название заклинания",
                label_spell_type: "Тип",
                tooltip_spell_type: "Выберите тип заклинания",
                label_power_set: "Набор сил",
                tooltip_power_set: "Выберите основную категорию заклинания",
                label_power_set_tree: "Подкатегория",
                tooltip_power_set_tree: "Выберите конкретную подкатегорию",
                label_level: "Уровень/Ранг/Требования",
                tooltip_level: "Укажите уровень или требования",
                placeholder_level: "например, 5-й уровень, Ранг 3",
                label_description: "Описание",
                tooltip_description: "Опишите повествовательный эффект заклинания",
                placeholder_description: "Опишите эффект заклинания",
                label_action: "Действие",
                tooltip_action: "Тип действия, необходимого для использования",
                label_target: "Цель",
                tooltip_target: "Кого или что затрагивает заклинание",
                label_range: "Дальность/Радиус",
                tooltip_range: "Дальность или радиус действия заклинания",
                label_duration: "Длительность",
                tooltip_duration: "Как долго длится заклинание",
                label_effect: "Эффект",
                tooltip_effect: "Механический эффект заклинания",
                placeholder_effect: "например, Наносит 4d6 урона огнём",
                label_cooldown: "Перезарядка",
                tooltip_cooldown: "Время до повторного использования заклинания",
                label_cost: "Стоимость",
                tooltip_cost: "Затраты на применение заклинания",
                label_defense: "Защита",
                tooltip_defense: "Защитные атрибуты, влияющие на заклинание",
                label_attack: "Атака",
                tooltip_attack: "Атакующие атрибуты, усиливающие заклинание",
                label_restrictions: "Ограничения/Условия",
                tooltip_restrictions: "Ограничения заклинания",
                placeholder_restrictions: "например, Требуется прямая видимость",
                label_upgrades: "Варианты/Улучшения",
                tooltip_upgrades: "Возможные улучшения или варианты",
                placeholder_upgrades: "например, Радиус увеличивается на 10-м уровне",
                save_spell: "Сохранить заклинание",
                load_spell: "Загрузить последнее заклинание",
                clear_form: "Очистить форму",
                list_title: "Список заклинаний",
                placeholder_filter_name: "Фильтр по названию",
                table_name: "Название",
                table_power_set: "Набор сил",
                table_power_set_tree: "Подкатегория",
                table_type: "Тип",
                table_action: "Действие",
                delete_spell: "Удалить",
                edit_spell: "Редактировать",
                close_modal: "Закрыть",
                modal_title: "Детали заклинания",
                confirm_delete: "Вы уверены, что хотите удалить это заклинание?",
                confirm_delete_title: "Подтверждение удаления",
                confirm: "Подтвердить",
                cancel: "Отмена",
                manager_title: "Управление списками",
                label_manager_list_type: "Выберите список для управления:",
                manager_type: "Список типов",
                placeholder_new_type: "Добавить новый тип",
                add_type: "Добавить",
                manager_power_set: "Список наборов сил",
                placeholder_new_power_set: "Добавить новый набор сил",
                add_power_set: "Добавить",
                manager_power_set_tree: "Список подкатегорий",
                label_power_set_select: "Выберите набор сил",
                placeholder_new_power_set_tree: "Добавить новую подкатегорию",
                add_power_set_tree: "Добавить",
                manager_action: "Список действий",
                placeholder_new_action: "Добавить новое действие",
                add_action: "Добавить",
                manager_target: "Список целей",
                placeholder_new_target: "Добавить новую цель",
                add_target: "Добавить",
                manager_range: "Список дальности/радиуса",
                placeholder_new_range: "Добавить новую дальность/радиус",
                add_range: "Добавить",
                manager_duration: "Список длительностей",
                placeholder_new_duration: "Добавить новую длительность",
                add_duration: "Добавить",
                manager_cooldown: "Список перезарядок",
                placeholder_new_cooldown: "Добавить новую перезарядку",
                add_cooldown: "Добавить",
                manager_cost: "Список стоимостей",
                placeholder_new_cost: "Добавить новую стоимость",
                add_cost: "Добавить",
                manager_defense: "Список защит",
                placeholder_new_defense: "Добавить новую защиту",
                add_defense: "Добавить",
                manager_attack: "Список атак",
                placeholder_new_attack: "Добавить новую атаку",
                add_attack: "Добавить",
                export_data: "Экспорт данных",
                import_data: "Импорт данных",
                remove_button: "-",
                add_button: "+"
            }
        };

        // Initial dropdown data
        const dropdownData = {
            type: ["Combat", "Magical", "Social", "Passive", "Active", "Reaction"],
            powerSets: {
                "Academic": ["Culture and History", "Law and Politics", "Linguistics", "Mathematics", "Natural Sciences", "Religion and Magic"],
                "Black Magic": ["Curses", "Dark Rituals", "Death Magic", "Demonology", "Forbidden Knowledge", "Necromancy"],
                "Blood Magic": ["Blood Bonds", "Blood Control", "Blood Sense", "Blood Transfusion", "Crimson Empowerment", "Power Drain"],
                "Craft": ["Alchemy and Gastronomy", "Blacksmithing", "Enchantment", "Engineering", "Jewelcrafting", "Tailoring"],
                "Creation": ["Acting", "Architecture", "Artificing", "Literature", "Music", "Painting"],
                "Defense": ["Heavy Armor", "Light Armor", "Medium Armor", "Occult Defense", "Shield Mastery", "Unarmored"],
                "Elemental Control": ["Air", "Earth", "Electricity", "Fire", "Ice", "Light"],
                "Magic of Gods": ["Divination", "Magic of Godstones", "Portal Magic", "Rune Magic", "Soul Manipulation", "Summoning"],
                "Martial Arts": ["Axes", "Blunt", "Daggers", "Hand-To-Hand", "Polearms", "Swords"],
                "Mind Magic": ["Absorb Knowledge", "Illusion", "Mana Control", "Memory Manipulation", "Mental Fortress", "Telepathy"],
                "Mind Mastery": ["Discipline", "Ego", "Empathy", "Intuition", "Logic", "Will"],
                "Physical Mastery": ["Agility", "Dexterity", "Endurance", "Resilience", "Speed", "Strength"],
                "Ranged Weapon": ["Bow", "Crossbow", "Fire-Arm Weapon", "Magic Weapon", "Siege Weapon", "Throwing Weapon"],
                "Sense": ["Foresight", "Hearing", "Memory", "Sight", "Taste and Smell", "Touch"],
                "Speech": ["Bluff", "Intimidate", "Leadership", "Psychology", "Seduction", "Trade"],
                "Survival": ["Cooking", "Gathering", "Hunting", "Local Knowledge", "Making Traps", "Navigation"],
                "Transport Control": ["Driving", "Ethereal Travel", "Piloting", "Portal Mastery", "Riding", "Sailing"],
                "White Magic": ["Blessing", "Calling", "Purification", "Restoration", "Transmutation", "Weather Control"]
            },
            action: ["Standard", "Bonus", "Reaction", "Passive", "Instant"],
            target: ["Single Target", "Area", "Ally", "Enemy", "Self"],
            range: ["30 feet", "15-foot cone", "10 yards", "Instant", "Touch"],
            duration: ["Instantaneous", "1 minute", "1 hour", "Until end of combat", "Permanent"],
            cooldown: ["Once per short rest", "Once per long rest", "1 turn", "None"], // Separated cooldown
            cost: ["1 spell slot (3rd level)", "75 mana", "2 power points", "5 HP"], // Separated cost
            defense: ["Vigilance", "Dodge", "Magic Resistance", "Endurance", "Influence"],
            attack: ["Intrigue", "Accuracy", "Spell Power", "Physical Strength", "Resolve"]
        };

        // Load saved data from localStorage
        let lists = JSON.parse(localStorage.getItem('dropdownData')) || dropdownData;
        let savedSpells = JSON.parse(localStorage.getItem('savedSpells')) || [];
        let currentLanguage = localStorage.getItem('language') || 'en';
        let tabOrder = JSON.parse(localStorage.getItem('tabOrder')) || ['spell-creator', 'spell-list', 'list-manager'];

        // Update interface language
        function updateLanguage() {
            const t = translations[currentLanguage];
            document.getElementById('title').textContent = t.title;
            document.getElementById('tab-creator').textContent = t.tab_creator;
            document.getElementById('tab-list').textContent = t.tab_list;
            document.getElementById('tab-manager').textContent = t.tab_manager;
            document.getElementById('creator-title').textContent = t.creator_title;
            document.getElementById('label-spell-name').textContent = t.label_spell_name;
            document.getElementById('label-spell-name').setAttribute('data-tooltip', t.tooltip_spell_name);
            document.getElementById('spell-name').placeholder = t.placeholder_spell_name;
            document.getElementById('label-spell-type').textContent = t.label_spell_type;
            document.getElementById('label-spell-type').setAttribute('data-tooltip', t.tooltip_spell_type);
            document.getElementById('label-power-set').textContent = t.label_power_set;
            document.getElementById('label-power-set').setAttribute('data-tooltip', t.tooltip_power_set);
            document.getElementById('label-power-set-tree').textContent = t.label_power_set_tree;
            document.getElementById('label-power-set-tree').setAttribute('data-tooltip', t.tooltip_power_set_tree);
            document.getElementById('label-level').textContent = t.label_level;
            document.getElementById('label-level').setAttribute('data-tooltip', t.tooltip_level);
            // This placeholder is for the *first* dynamic input, which is handled by clearAndPopulateDynamicInputs
            // document.getElementById('level-0').placeholder = t.placeholder_level;
            document.getElementById('label-description').textContent = t.label_description;
            document.getElementById('label-description').setAttribute('data-tooltip', t.tooltip_description);
            document.getElementById('description').placeholder = t.placeholder_description;
            document.getElementById('label-action').textContent = t.label_action;
            document.getElementById('label-action').setAttribute('data-tooltip', t.tooltip_action);
            document.getElementById('label-target').textContent = t.label_target;
            document.getElementById('label-target').setAttribute('data-tooltip', t.tooltip_target);
            document.getElementById('label-range').textContent = t.label_range;
            document.getElementById('label-range').setAttribute('data-tooltip', t.tooltip_range);
            document.getElementById('label-duration').textContent = t.label_duration;
            document.getElementById('label-duration').setAttribute('data-tooltip', t.tooltip_duration);
            document.getElementById('label-effect').textContent = t.label_effect;
            document.getElementById('label-effect').setAttribute('data-tooltip', t.tooltip_effect);
            document.getElementById('effect').placeholder = t.placeholder_effect;
            document.getElementById('label-cooldown').textContent = t.label_cooldown;
            document.getElementById('label-cooldown').setAttribute('data-tooltip', t.tooltip_cooldown);
            document.getElementById('label-cost').textContent = t.label_cost;
            document.getElementById('label-cost').setAttribute('data-tooltip', t.tooltip_cost);
            document.getElementById('label-defense').textContent = t.label_defense;
            document.getElementById('label-defense').setAttribute('data-tooltip', t.tooltip_defense);
            document.getElementById('label-attack').textContent = t.label_attack;
            document.getElementById('label-attack').setAttribute('data-tooltip', t.tooltip_attack);
            document.getElementById('label-restrictions').textContent = t.label_restrictions;
            document.getElementById('label-restrictions').setAttribute('data-tooltip', t.tooltip_restrictions);
            // document.getElementById('restrictions-0').placeholder = t.placeholder_restrictions;
            document.getElementById('label-upgrades').textContent = t.label_upgrades;
            document.getElementById('label-upgrades').setAttribute('data-tooltip', t.tooltip_upgrades);
            // document.getElementById('upgrades-0').placeholder = t.placeholder_upgrades;

            // Set button texts
            document.getElementById('save-spell').textContent = t.save_spell;
            document.getElementById('load-spell').textContent = t.load_spell;
            document.getElementById('clear-form').textContent = t.clear_form;

            document.getElementById('list-title').textContent = t.list_title;
            document.getElementById('filter-name').placeholder = t.placeholder_filter_name; // Corrected ID
            document.getElementById('table-name').textContent = t.table_name;
            document.getElementById('table-power-set').textContent = t.table_power_set;
            document.getElementById('table-power-set-tree').textContent = t.table_power_set_tree;
            document.getElementById('table-type').textContent = t.table_type;
            document.getElementById('table-action').textContent = t.table_action;
            document.getElementById('manager-title').textContent = t.manager_title;
            document.getElementById('label-manager-list-type').textContent = t.label_manager_list_type;
            document.getElementById('manager-type').textContent = t.manager_type;
            document.getElementById('new-type').placeholder = t.placeholder_new_type;
            document.getElementById('add-type').textContent = t.add_type;
            document.getElementById('manager-power-set').textContent = t.manager_power_set;
            document.getElementById('new-power-set').placeholder = t.placeholder_new_power_set;
            document.getElementById('add-power-set').textContent = t.add_power_set;
            document.getElementById('manager-power-set-tree').textContent = t.manager_power_set_tree;
            document.getElementById('label-power-set-select').textContent = t.label_power_set_select;
            document.getElementById('new-power-set-tree').placeholder = t.placeholder_new_power_set_tree;
            document.getElementById('add-power-set-tree').textContent = t.add_power_set_tree;
            document.getElementById('manager-action').textContent = t.manager_action;
            document.getElementById('new-action').placeholder = t.placeholder_new_action;
            document.getElementById('add-action').textContent = t.add_action;
            document.getElementById('manager-target').textContent = t.manager_target;
            document.getElementById('new-target').placeholder = t.placeholder_new_target;
            document.getElementById('add-target').textContent = t.add_target;
            document.getElementById('manager-range').textContent = t.manager_range;
            document.getElementById('new-range').placeholder = t.placeholder_new_range;
            document.getElementById('add-range').textContent = t.add_range;
            document.getElementById('manager-duration').textContent = t.manager_duration;
            document.getElementById('new-duration').placeholder = t.placeholder_new_duration;
            document.getElementById('add-duration').textContent = t.add_duration;
            document.getElementById('manager-cooldown').textContent = t.manager_cooldown;
            document.getElementById('new-cooldown').placeholder = t.placeholder_new_cooldown;
            document.getElementById('add-cooldown').textContent = t.add_cooldown;
            document.getElementById('manager-cost').textContent = t.manager_cost;
            document.getElementById('new-cost').placeholder = t.placeholder_new_cost;
            document.getElementById('add-cost').textContent = t.add_cost;
            document.getElementById('manager-defense').textContent = t.manager_defense;
            document.getElementById('new-defense').placeholder = t.placeholder_new_defense;
            document.getElementById('add-defense').textContent = t.add_defense;
            document.getElementById('manager-attack').textContent = t.manager_attack;
            document.getElementById('new-attack').placeholder = t.placeholder_new_attack;
            document.getElementById('add-attack').textContent = t.add_attack;
            document.getElementById('export-data').textContent = t.export_data;
            document.getElementById('import-data').textContent = t.import_data;

            // Update text for existing dynamic buttons in the creator
            document.querySelectorAll('.dynamic-input-group button').forEach(button => {
                // Determine if it's an add or remove button based on its current action
                if (button.onclick && button.onclick.toString().includes('addRowToForm')) {
                    button.textContent = t.add_button;
                } else {
                    button.textContent = t.remove_button;
                }
            });
             // Update text for existing add/remove buttons in manager lists
            document.querySelectorAll('.list-manager .input-group button').forEach(button => {
                if (button.id.startsWith('add-')) { // Assuming buttons with 'add-' ID prefix are add buttons
                    button.textContent = t.add_button;
                }
            });
            document.querySelectorAll('.list-manager .list-item button').forEach(button => {
                 button.textContent = t.remove_button; // All buttons in list-item are remove buttons
            });
        }

        // Switch language
        function switchLanguage(lang) {
            currentLanguage = lang;
            localStorage.setItem('language', lang);
            document.querySelectorAll('.tab-content').forEach(content => {
                content.style.opacity = '0';
                setTimeout(() => {
                    content.style.opacity = '1';
                    updateLanguage();
                    // Re-initialize dynamic inputs *before* populating dropdowns
                    initializeDynamicInputs();
                    populateDropdowns();
                    updateSpellList();
                    // Re-initialize the currently active list in manager if it's open
                    showManagedList();
                }, 300);
            });
        }

        // Initialize tabs order
        function initializeTabs() {
            const tabsContainer = document.getElementById('tabs');
            const tabs = Array.from(document.querySelectorAll('.tab'));
            tabsContainer.innerHTML = '';
            tabOrder.forEach(tabId => {
                const tab = tabs.find(t => t.dataset.tab === tabId);
                if (tab) tabsContainer.appendChild(tab);
            });

            // Drag-and-drop for tabs
            tabs.forEach(tab => {
                tab.addEventListener('dragstart', (e) => {
                    tab.classList.add('dragging');
                    e.dataTransfer.setData('text/plain', tab.dataset.tab);
                });
                tab.addEventListener('dragend', () => {
                    tab.classList.remove('dragging');
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('drag-over'));
                });
                tab.addEventListener('dragover', (e) => e.preventDefault());
                tab.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    tab.classList.add('drag-over');
                });
                tab.addEventListener('dragleave', () => {
                    tab.classList.remove('drag-over');
                });
                tab.addEventListener('drop', (e) => {
                    e.preventDefault();
                    const draggedTabId = e.dataTransfer.getData('text/plain');
                    const targetTabId = tab.dataset.tab;
                    if (draggedTabId !== targetTabId) {
                        const newOrder = tabOrder.filter(id => id !== draggedTabId);
                        const targetIndex = newOrder.indexOf(targetTabId);
                        newOrder.splice(targetIndex, 0, draggedTabId);
                        tabOrder = newOrder;
                        localStorage.setItem('tabOrder', JSON.stringify(tabOrder));
                        initializeTabs();
                    }
                    tab.classList.remove('drag-over');
                });
            });
        }

        // Export data to JSON file
        function exportData() {
            const data = {
                dropdownData: lists,
                savedSpells: savedSpells,
                tabOrder: tabOrder
            };
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'grimoire_data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        // Import data from JSON file
        function importData(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        if (data.dropdownData && data.savedSpells) {
                            lists = data.dropdownData;
                            savedSpells = data.savedSpells;
                            tabOrder = data.tabOrder || tabOrder;
                            localStorage.setItem('dropdownData', JSON.stringify(lists));
                            localStorage.setItem('savedSpells', JSON.stringify(savedSpells));
                            localStorage.setItem('tabOrder', JSON.stringify(tabOrder));
                            initializeTabs();
                            // Re-initialize the first set of dynamic inputs before populating dropdowns
                            initializeDynamicInputs();
                            populateDropdowns();
                            showManagedList(); // Re-initialize based on selected manager list
                            updateSpellList();
                            showTab(localStorage.getItem('activeTab') || 'spell-creator');
                        } else {
                            console.error('Invalid file format');
                        }
                    } catch (error) {
                        console.error('Error reading file:', error.message);
                    }
                };
                reader.readAsText(file);
            }
        }

        // Populate all dropdowns
        function populateDropdowns() {
            // Spell Creator Dropdowns
            // Use an array of objects to map containerId to listName for clarity
            const selectFields = [
                { id: 'spell-type-container', listName: 'type' },
                { id: 'action-container', listName: 'action' },
                { id: 'target-container', listName: 'target' },
                { id: 'range-container', listName: 'range' },
                { id: 'duration-container', listName: 'duration' },
                { id: 'cooldown-container', listName: 'cooldown' },
                { id: 'cost-container', listName: 'cost' },
                { id: 'defense-container', listName: 'defense' },
                { id: 'attack-container', listName: 'attack' }
            ];

            selectFields.forEach(fieldConfig => {
                const container = document.getElementById(fieldConfig.id);
                const listData = lists[fieldConfig.listName] || [];
                const firstSelectElement = container.querySelector('select'); // Get the first select in the container
                if (firstSelectElement) {
                    firstSelectElement.innerHTML = '';
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.text = "-- Select --"; // or localized text
                    firstSelectElement.appendChild(defaultOption);

                    listData.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item;
                        option.text = item;
                        firstSelectElement.appendChild(option);
                    });
                }
            });


            // Power Set (Spell Creator)
            const powerSetOptions = Object.keys(lists.powerSets);
            const firstPowerSetSelect = document.getElementById('power-set-0');
            if (firstPowerSetSelect) {
                firstPowerSetSelect.innerHTML = '';
                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.text = "-- Select --";
                firstPowerSetSelect.appendChild(defaultOption);
                powerSetOptions.forEach(set => {
                    const option = document.createElement('option');
                    option.value = set;
                    option.text = set;
                    firstPowerSetSelect.appendChild(option);
                });
            }

            // Power Set Tree (initial update after power set is populated)
            updatePowerSetTree();

            // Power Set for Manager
            const powerSetSelectEdit = document.getElementById('power-set-select');
            powerSetSelectEdit.innerHTML = '';
            powerSetOptions.forEach(set => {
                const option = document.createElement('option');
                option.value = set;
                option.text = set;
                powerSetSelectEdit.appendChild(option);
            });

            // Filter Dropdowns
            const filterPowerSet = document.getElementById('filter-power-set');
            filterPowerSet.innerHTML = `<option value="">${translations[currentLanguage].table_power_set}</option>`;
            powerSetOptions.forEach(set => {
                const option = document.createElement('option');
                option.value = set;
                option.text = set;
                filterPowerSet.appendChild(option);
            });

            const filterType = document.getElementById('filter-type');
            filterType.innerHTML = `<option value="">${translations[currentLanguage].table_type}</option>`;
            lists.type.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.text = item;
                filterType.appendChild(option);
            });

            // Update Filter Power Set Tree (initial update after filter power set is populated)
            updateFilterPowerSetTree();
        }

        // Populate Power Set Tree dropdown
        function updatePowerSetTree() {
            const powerSetSelect = document.getElementById('power-set-0');
            const powerSetTreeContainer = document.getElementById('power-set-tree-container');

            if (!powerSetSelect || !powerSetTreeContainer) return; // Ensure elements exist

            const powerSet = powerSetSelect.value;
            const powerSetTreeList = lists.powerSets[powerSet] || [];

            // Get the current value(s) of power-set-tree inputs to re-select after update
            const currentPowerSetTreeValues = getAllInputValues('power-set-tree-container');

            // Clear and repopulate the *existing* power-set-tree select elements
            const existingPowerSetTreeSelects = powerSetTreeContainer.querySelectorAll('select');
            existingPowerSetTreeSelects.forEach((selectElement, index) => {
                selectElement.innerHTML = '';
                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.text = "-- Select --";
                selectElement.appendChild(defaultOption);

                powerSetTreeList.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item;
                    option.text = item;
                    selectElement.appendChild(option);
                });

                // Attempt to re-select the previous value if it exists in the new list
                if (currentPowerSetTreeValues[index] && powerSetTreeList.includes(currentPowerSetTreeValues[index])) {
                    selectElement.value = currentPowerSetTreeValues[index];
                }
            });

            // If there are no existing power-set-tree selects (e.g., initial load or all removed),
            // ensure at least one is added and populated.
            if (existingPowerSetTreeSelects.length === 0) {
                 clearAndPopulateDynamicInputs('power-set-tree-container', [], true, powerSetTreeList, 'power-set-tree');
            }
        }

        // Populate Filter Power Set Tree dropdown
        function updateFilterPowerSetTree() {
            const filterPowerSet = document.getElementById('filter-power-set');
            const powerSet = filterPowerSet.value;
            const powerSetTreeSelect = document.getElementById('filter-power-set-tree');
            powerSetTreeSelect.innerHTML = `<option value="">${translations[currentLanguage].table_power_set_tree}</option>`;
            if (lists.powerSets[powerSet]) {
                lists.powerSets[powerSet].forEach(tree => {
                    const option = document.createElement('option');
                    option.value = tree;
                    option.text = tree;
                    powerSetTreeSelect.appendChild(option);
                });
            }
            updateSpellList();
        }

        // Populate Power Set Tree for editing
        function loadPowerSetTreeForEdit() {
            const powerSet = document.getElementById('power-set-select').value;
            const powerSetTreeListElement = document.getElementById('power-set-tree-list');
            powerSetTreeListElement.innerHTML = '';
            if (lists.powerSets[powerSet]) {
                lists.powerSets[powerSet].forEach(tree => {
                    const div = document.createElement('div');
                    div.className = 'list-item';
                    div.innerHTML = `
                        ${tree} <button onclick="removePowerSetTree('${powerSet}', '${tree}')">${translations[currentLanguage].remove_button}</button>
                    `;
                    powerSetTreeListElement.appendChild(div);
                });
            }
        }

        // Add new Power Set
        function addPowerSet() {
            const newPowerSet = document.getElementById('new-power-set').value.trim();
            if (newPowerSet && !lists.powerSets[newPowerSet]) {
                lists.powerSets[newPowerSet] = [];
                localStorage.setItem('dropdownData', JSON.stringify(lists));
                populateDropdowns(); // Re-populate dropdowns including power-set-0
                updatePowerSetList();
                document.getElementById('new-power-set').value = '';
            }
        }

        // Add new Power Set Tree
        function addPowerSetTree() {
            const powerSet = document.getElementById('power-set-select').value;
            const newTree = document.getElementById('new-power-set-tree').value.trim();
            if (newTree && lists.powerSets[powerSet] && !lists.powerSets[powerSet].includes(newTree)) {
                lists.powerSets[powerSet].push(newTree);
                localStorage.setItem('dropdownData', JSON.stringify(lists));
                populateDropdowns(); // Re-populate to update power-set-tree-0
                loadPowerSetTreeForEdit();
                updateFilterPowerSetTree();
                document.getElementById('new-power-set-tree').value = '';
            }
        }

        // Remove Power Set Tree
        function removePowerSetTree(powerSet, tree) {
            const listItem = Array.from(document.querySelectorAll('#power-set-tree-list .list-item')).find(item => item.textContent.includes(tree));
            if (listItem) {
                listItem.classList.add('shake', 'removing');
                setTimeout(() => {
                    lists.powerSets[powerSet] = lists.powerSets[powerSet].filter(t => t !== tree);
                    localStorage.setItem('dropdownData', JSON.stringify(lists));
                    populateDropdowns(); // Re-populate to update power-set-tree-0
                    loadPowerSetTreeForEdit();
                    updateFilterPowerSetTree();
                }, 500);
            }
        }

        // Add new item to dropdown lists
        function addListItem(listName, inputId) {
            const newItem = document.getElementById(inputId).value.trim();
            if (newItem && !lists[listName].includes(newItem)) {
                lists[listName].push(newItem);
                localStorage.setItem('dropdownData', JSON.stringify(lists));
                populateDropdowns();
                updateList(listName);
                document.getElementById(inputId).value = '';
            }
        }

        // Remove item from dropdown lists
        function removeListItem(listName, item) {
            const listItem = Array.from(document.querySelectorAll(`#${listName}-list .list-item`)).find(el => el.textContent.includes(item));
            if (listItem) {
                listItem.classList.add('shake', 'removing');
                setTimeout(() => {
                    lists[listName] = lists[listName].filter(i => i !== item);
                    localStorage.setItem('dropdownData', JSON.stringify(lists));
                    populateDropdowns();
                    updateList(listName);
                }, 500);
            }
        }

        // Update dropdown list in manager
        function updateList(listName) {
            const listElement = document.getElementById(`${listName}-list`);
            listElement.innerHTML = '';
            if (lists[listName]) { // Ensure the list exists
                lists[listName].forEach(item => {
                    const div = document.createElement('div');
                    div.className = 'list-item';
                    div.innerHTML = `
                        <span>${item}</span> <button onclick="removeListItem('${listName}', '${item}')">${translations[currentLanguage].remove_button}</button>
                    `;
                    listElement.appendChild(div);
                });
            }
        }

        // Update Power Set list in manager
        function updatePowerSetList() {
            const powerSetList = document.getElementById('power-set-list');
            powerSetList.innerHTML = '';
            for (let set in lists.powerSets) {
                const div = document.createElement('div');
                div.className = 'list-item';
                div.innerHTML = `
                    <span>${set}</span> <button onclick="removePowerSet('${set}')">${translations[currentLanguage].remove_button}</button>
                `;
                powerSetList.appendChild(div);
            }
        }

        // Remove Power Set
        function removePowerSet(powerSet) {
            const listItem = Array.from(document.querySelectorAll('#power-set-list .list-item')).find(item => item.textContent.includes(powerSet));
            if (listItem) {
                listItem.classList.add('shake', 'removing');
                setTimeout(() => {
                    delete lists.powerSets[powerSet];
                    localStorage.setItem('dropdownData', JSON.stringify(lists));
                    populateDropdowns();
                    updatePowerSetList();
                    updateSpellList();
                }, 500);
            }
        }

        // Add a new row (input/select) for dynamic fields
        function addRowToForm(field) {
            const container = document.getElementById(`${field}-container`);
            const currentIndex = container.children.length;

            const div = document.createElement('div');
            div.className = 'dynamic-input-group';

            let inputElement;
            const isSelectField = ['spell-type', 'power-set', 'power-set-tree', 'action', 'target', 'range', 'duration', 'cooldown', 'cost', 'defense', 'attack'].includes(field);

            if (isSelectField) {
                inputElement = document.createElement('select');
                inputElement.id = `${field}-${currentIndex}`;
                let dropdownList = [];
                if (field === 'power-set') {
                    dropdownList = Object.keys(lists.powerSets);
                } else if (field === 'power-set-tree') {
                    const selectedPowerSet = getAllInputValues('power-set-container')[0] || ''; // Get the value from the first power-set dropdown
                    dropdownList = lists.powerSets[selectedPowerSet] || [];
                } else if (field === 'spell-type') { // Explicitly handle spell-type
                    dropdownList = lists.type;
                }
                else {
                    dropdownList = lists[field] || [];
                }

                // Add a default empty option for new select elements
                const defaultOption = document.createElement('option');
                defaultOption.value = "";
                defaultOption.text = "-- Select --";
                inputElement.appendChild(defaultOption);

                dropdownList.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item;
                    option.text = item;
                    inputElement.appendChild(option);
                });

                if (field === 'power-set') {
                    inputElement.onchange = updatePowerSetTree; // Attach onchange event for power-set dropdowns
                }

            } else {
                inputElement = document.createElement('input');
                inputElement.type = 'text';
                inputElement.id = `${field}-${currentIndex}`;
                inputElement.placeholder = translations[currentLanguage][`placeholder_${field}`] || '';
            }

            const removeButton = document.createElement('button');
            removeButton.type = 'button';
            removeButton.textContent = translations[currentLanguage].remove_button; // All new buttons are remove buttons
            removeButton.onclick = (e) => removeRowFromForm(e.target, field);

            // Update the previous button to be '-' if it was '+'
            if (currentIndex > 0) {
                const prevButton = container.children[currentIndex - 1].querySelector('button');
                if (prevButton && prevButton.textContent === translations[currentLanguage].add_button) {
                    prevButton.textContent = translations[currentLanguage].remove_button;
                    prevButton.onclick = (e) => removeRowFromForm(e.target, field);
                }
            }


            div.appendChild(inputElement);
            div.appendChild(removeButton);
            container.appendChild(div);

             // Ensure the last button is always '+'
             const lastButton = container.lastElementChild.querySelector('button');
             if (lastButton) {
                lastButton.textContent = translations[currentLanguage].add_button;
                lastButton.onclick = () => addRowToForm(field);
             }
        }

        // Remove a dynamically added row
        function removeRowFromForm(buttonElement, field) {
            const group = buttonElement.parentNode;
            const container = document.getElementById(`${field}-container`);
            group.classList.add('removing');
            setTimeout(() => {
                group.remove();

                // If only one row remains, make sure its button is '+'
                if (container.children.length === 1) {
                    const remainingButton = container.children[0].querySelector('button');
                    if (remainingButton) {
                        remainingButton.textContent = translations[currentLanguage].add_button;
                        remainingButton.onclick = () => addRowToForm(field);
                    }
                } else if (container.children.length > 1) {
                    // If multiple rows remain, ensure the *last* button is '+'
                    const lastButton = container.lastElementChild.querySelector('button');
                    if (lastButton) {
                        lastButton.textContent = translations[currentLanguage].add_button;
                        lastButton.onclick = () => addRowToForm(field);
                    }
                } else {
                    // If all rows are removed, re-add one empty row with an "add" button
                    const isSelect = ['spell-type', 'power-set', 'power-set-tree', 'action', 'target', 'range', 'duration', 'cooldown', 'cost', 'defense', 'attack'].includes(field);
                    let dropdownOptions = [];
                    if (isSelect) {
                        if (field === 'power-set') {
                            dropdownOptions = Object.keys(lists.powerSets);
                        } else if (field === 'power-set-tree') {
                            // When recreating, power-set-0 might not have a value yet
                            const currentPowerSet = document.getElementById('power-set-0')?.value || '';
                            dropdownOptions = lists.powerSets[currentPowerSet] || [];
                        } else if (field === 'spell-type') {
                            dropdownOptions = lists.type;
                        } else {
                            dropdownOptions = lists[field];
                        }
                    }
                    clearAndPopulateDynamicInputs(container.id, [], isSelect, dropdownOptions, field);
                }
            }, 300);
        }

        // Get all values from dynamic input groups
        function getAllInputValues(containerId) {
            const container = document.getElementById(containerId);
            if (!container) return [];
            const inputs = container.querySelectorAll('input[type="text"], select');
            return Array.from(inputs).map(input => input.value).filter(value => value.trim() !== '');
        }

        // Clear existing dynamic inputs and populate with new values
        function clearAndPopulateDynamicInputs(containerId, values, isSelect = false, dropdownList = [], fieldNameOverride = null) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear all existing dynamic inputs

            const fieldName = fieldNameOverride || containerId.replace('-container', '');

            if (values.length === 0) {
                // If no values, add one empty row with an "add" button
                const div = document.createElement('div');
                div.className = 'dynamic-input-group';
                let inputElement;
                if (isSelect) {
                    inputElement = document.createElement('select');
                    // Add a default empty option for select elements
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.text = "-- Select --"; // or localized text
                    inputElement.appendChild(defaultOption);

                    // Determine dropdown list based on containerId
                    let currentDropdownList = dropdownList; // Use passed dropdownList by default
                    if (containerId === 'spell-type-container') {
                        currentDropdownList = lists.type; // Explicitly use lists.type
                    } else if (containerId === 'power-set-container') {
                        currentDropdownList = Object.keys(lists.powerSets);
                    } else if (containerId === 'power-set-tree-container') {
                        const selectedPowerSet = document.getElementById('power-set-0')?.value || '';
                        currentDropdownList = lists.powerSets[selectedPowerSet] || [];
                    } else if (lists[fieldName]) { // Fallback if not a special case
                        currentDropdownList = lists[fieldName];
                    }


                    currentDropdownList.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item;
                        option.text = item;
                        inputElement.appendChild(option);
                    });
                } else {
                    inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.placeholder = translations[currentLanguage][`placeholder_${fieldName}`] || '';
                }
                inputElement.id = `${fieldName}-0`; // Give it an ID

                // Attach onchange for power-set-0 specifically if it's a new element
                if (fieldName === 'power-set') {
                    inputElement.onchange = updatePowerSetTree;
                }

                const addButton = document.createElement('button');
                addButton.type = 'button';
                addButton.textContent = translations[currentLanguage].add_button; // Localized add button
                addButton.onclick = () => addRowToForm(fieldName);

                div.appendChild(inputElement);
                div.appendChild(addButton);
                container.appendChild(div);
                return;
            }

            values.forEach((value, index) => {
                const div = document.createElement('div');
                div.className = 'dynamic-input-group';

                let inputElement;
                if (isSelect) {
                    inputElement = document.createElement('select');
                    const defaultOption = document.createElement('option');
                    defaultOption.value = "";
                    defaultOption.text = "-- Select --";
                    inputElement.appendChild(defaultOption);

                    // Determine dropdown list based on containerId for existing values
                    let currentDropdownList = dropdownList; // Use passed dropdownList by default
                    if (containerId === 'spell-type-container') {
                        currentDropdownList = lists.type; // Explicitly use lists.type
                    } else if (containerId === 'power-set-container') {
                        currentDropdownList = Object.keys(lists.powerSets);
                    } else if (containerId === 'power-set-tree-container') {
                        // For existing power-set-tree elements, try to derive from existing power-set values
                        const currentPowerSet = getAllInputValues('power-set-container')[0] || Object.keys(lists.powerSets)[0] || '';
                        currentDropdownList = lists.powerSets[currentPowerSet] || [];
                    } else if (lists[fieldName]) { // Fallback if not a special case
                        currentDropdownList = lists[fieldName];
                    }

                    currentDropdownList.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item;
                        option.text = item;
                        inputElement.appendChild(option);
                    });
                    inputElement.value = value; // Set selected value
                } else {
                    inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.value = value;
                    inputElement.placeholder = translations[currentLanguage][`placeholder_${fieldName}`] || '';
                }
                inputElement.id = `${fieldName}-${index}`; // Assign an ID

                // Attach onchange for power-set elements if they are created
                if (fieldName === 'power-set') {
                    inputElement.onchange = updatePowerSetTree;
                }

                const button = document.createElement('button');
                button.type = 'button';
                button.textContent = (index === values.length - 1) ? translations[currentLanguage].add_button : translations[currentLanguage].remove_button; // Localized buttons
                button.onclick = (index === values.length - 1) ? () => addRowToForm(fieldName) : (e) => removeRowFromForm(e.target, fieldName);

                div.appendChild(inputElement);
                div.appendChild(button);
                container.appendChild(div);
            });
        }

        // Initialize all dynamic input containers with one default row
        function initializeDynamicInputs() {
            const dynamicConfigs = [
                { id: 'spell-type-container', isSelect: true, listKey: 'type' },
                { id: 'power-set-container', isSelect: true, listKey: 'powerSets' },
                { id: 'power-set-tree-container', isSelect: true, listKey: 'powerSetTree' },
                { id: 'level-container', isSelect: false, listKey: null },
                { id: 'action-container', isSelect: true, listKey: 'action' },
                { id: 'target-container', isSelect: true, listKey: 'target' },
                { id: 'range-container', isSelect: true, listKey: 'range' },
                { id: 'duration-container', isSelect: true, listKey: 'duration' },
                { id: 'cooldown-container', isSelect: true, listKey: 'cooldown' },
                { id: 'cost-container', isSelect: true, listKey: 'cost' },
                { id: 'defense-container', isSelect: true, listKey: 'defense' },
                { id: 'attack-container', isSelect: true, listKey: 'attack' },
                { id: 'restrictions-container', isSelect: false, listKey: null },
                { id: 'upgrades-container', isSelect: false, listKey: null }
            ];

            dynamicConfigs.forEach(config => {
                const fieldName = config.id.replace('-container', '');
                let dropdownOptions = [];
                if (config.isSelect && config.listKey) {
                    if (config.listKey === 'powerSets') {
                        dropdownOptions = Object.keys(lists.powerSets);
                    } else if (config.listKey === 'powerSetTree') {
                        const defaultPowerSet = Object.keys(lists.powerSets)[0] || '';
                        dropdownOptions = lists.powerSets[defaultPowerSet] || [];
                    } else {
                        dropdownOptions = lists[config.listKey];
                    }
                }
                clearAndPopulateDynamicInputs(config.id, [], config.isSelect, dropdownOptions, fieldName);
            });
        }


        // Save spell
        function saveSpell() {
            const spell = {
                name: document.getElementById('spell-name').value,
                type: getAllInputValues('spell-type-container'),
                powerSet: getAllInputValues('power-set-container'),
                powerSetTree: getAllInputValues('power-set-tree-container'),
                level: getAllInputValues('level-container'),
                description: document.getElementById('description').value,
                action: getAllInputValues('action-container'),
                target: getAllInputValues('target-container'),
                range: getAllInputValues('range-container'),
                duration: getAllInputValues('duration-container'),
                effect: document.getElementById('effect').value,
                cooldown: getAllInputValues('cooldown-container'),
                cost: getAllInputValues('cost-container'), // Get multiple costs
                defense: getAllInputValues('defense-container'),
                attack: getAllInputValues('attack-container'),
                restrictions: getAllInputValues('restrictions-container'),
                upgrades: getAllInputValues('upgrades-container')
            };

            // Convert single-item arrays back to string if desired for display purposes
            for (const key in spell) {
                // Keep cooldown, cost, restrictions, upgrades as arrays even if single item
                if (Array.isArray(spell[key]) && spell[key].length === 1 && !['cooldown', 'cost', 'restrictions', 'upgrades'].includes(key)) {
                    spell[key] = spell[key][0];
                } else if (Array.isArray(spell[key]) && spell[key].length === 0 && !['cooldown', 'cost', 'restrictions', 'upgrades'].includes(key)) {
                    spell[key] = ''; // Store as empty string if empty array for single fields
                }
            }


            const existingIndex = savedSpells.findIndex(s => s.name === spell.name);
            if (existingIndex >= 0) {
                savedSpells[existingIndex] = spell;
            } else {
                savedSpells.push(spell);
            }
            localStorage.setItem('savedSpells', JSON.stringify(savedSpells));
            updateSpellList();
            const form = document.getElementById('spell-form');
            form.classList.add('glow');
            setTimeout(() => form.classList.remove('glow'), 1000);
        }

        // Load spell
        function loadSpell(spell = null) {
            if (spell || savedSpells.length > 0) {
                const selectedSpell = spell || savedSpells[savedSpells.length - 1];
                document.getElementById('spell-name').value = selectedSpell.name || '';
                document.getElementById('description').value = selectedSpell.description || '';
                document.getElementById('effect').value = selectedSpell.effect || '';

                // Load dynamic fields
                clearAndPopulateDynamicInputs('spell-type-container', Array.isArray(selectedSpell.type) ? selectedSpell.type : [selectedSpell.type || ''], true, lists.type, 'type'); // Explicitly pass 'type' as fieldNameOverride and lists.type
                clearAndPopulateDynamicInputs('power-set-container', Array.isArray(selectedSpell.powerSet) ? selectedSpell.powerSet : [selectedSpell.powerSet || ''], true, Object.keys(lists.powerSets), 'power-set');
                // After populating power-set, update the power-set-tree dropdown based on the first power-set
                const firstPowerSet = (Array.isArray(selectedSpell.powerSet) ? selectedSpell.powerSet[0] : selectedSpell.powerSet) || Object.keys(lists.powerSets)[0];
                const powerSetTreeList = lists.powerSets[firstPowerSet] || [];
                clearAndPopulateDynamicInputs('power-set-tree-container', Array.isArray(selectedSpell.powerSetTree) ? selectedSpell.powerSetTree : [selectedSpell.powerSetTree || ''], true, powerSetTreeList, 'power-set-tree');

                clearAndPopulateDynamicInputs('level-container', Array.isArray(selectedSpell.level) ? selectedSpell.level : [selectedSpell.level || ''], false, [], 'level');
                clearAndPopulateDynamicInputs('action-container', Array.isArray(selectedSpell.action) ? selectedSpell.action : [selectedSpell.action || ''], true, lists.action, 'action');
                clearAndPopulateDynamicInputs('target-container', Array.isArray(selectedSpell.target) ? selectedSpell.target : [selectedSpell.target || ''], true, lists.target, 'target');
                clearAndPopulateDynamicInputs('range-container', Array.isArray(selectedSpell.range) ? selectedSpell.range : [selectedSpell.range || ''], true, lists.range, 'range');
                clearAndPopulateDynamicInputs('duration-container', Array.isArray(selectedSpell.duration) ? selectedSpell.duration : [selectedSpell.duration || ''], true, lists.duration, 'duration');
                clearAndPopulateDynamicInputs('cooldown-container', selectedSpell.cooldown || [], true, lists.cooldown, 'cooldown');
                clearAndPopulateDynamicInputs('cost-container', selectedSpell.cost || [], true, lists.cost, 'cost');
                clearAndPopulateDynamicInputs('defense-container', Array.isArray(selectedSpell.defense) ? selectedSpell.defense : [selectedSpell.defense || ''], true, lists.defense, 'defense');
                clearAndPopulateDynamicInputs('attack-container', Array.isArray(selectedSpell.attack) ? selectedSpell.attack : [selectedSpell.attack || ''], true, lists.attack, 'attack');
                clearAndPopulateDynamicInputs('restrictions-container', selectedSpell.restrictions || [], false, [], 'restrictions');
                clearAndPopulateDynamicInputs('upgrades-container', selectedSpell.upgrades || [], false, [], 'upgrades');

                showTab('spell-creator');
            }
        }


        // Clear form
        function clearForm() {
            const form = document.getElementById('spell-form');
            form.style.opacity = '0.5';
            setTimeout(() => {
                form.reset();
                // Clear and re-add initial rows for all dynamic input containers
                const dynamicConfigs = [
                    { id: 'spell-type-container', isSelect: true, listKey: 'type' },
                    { id: 'power-set-container', isSelect: true, listKey: 'powerSets' },
                    { id: 'power-set-tree-container', isSelect: true, listKey: 'powerSetTree' },
                    { id: 'level-container', isSelect: false, listKey: null },
                    { id: 'action-container', isSelect: true, listKey: 'action' },
                    { id: 'target-container', isSelect: true, listKey: 'target' },
                    { id: 'range-container', isSelect: true, listKey: 'range' },
                    { id: 'duration-container', isSelect: true, listKey: 'duration' },
                    { id: 'cooldown-container', isSelect: true, listKey: 'cooldown' },
                    { id: 'cost-container', isSelect: true, listKey: 'cost' },
                    { id: 'defense-container', isSelect: true, listKey: 'defense' },
                    { id: 'attack-container', isSelect: true, listKey: 'attack' },
                    { id: 'restrictions-container', isSelect: false, listKey: null },
                    { id: 'upgrades-container', isSelect: false, listKey: null }
                ];

                dynamicConfigs.forEach(config => {
                    const fieldName = config.id.replace('-container', '');
                    let dropdownOptions = [];
                    if (config.isSelect && config.listKey) {
                        if (config.listKey === 'powerSets') {
                            dropdownOptions = Object.keys(lists.powerSets);
                        } else if (config.listKey === 'powerSetTree') {
                            const selectedPowerSet = document.getElementById('power-set-0')?.value || '';
                            dropdownOptions = lists.powerSets[selectedPowerSet] || [];
                        } else {
                            dropdownOptions = lists[config.listKey];
                        }
                    }
                    clearAndPopulateDynamicInputs(config.id, [], config.isSelect, dropdownOptions, fieldName);
                });

                populateDropdowns(); // Re-populate dropdowns to ensure fresh initial values
                form.style.opacity = '1';
            }, 300);
        }


        // Show spell details in modal
        function showSpellDetails(spell, index) {
            const modal = document.getElementById('spell-modal');
            const modalContent = document.getElementById('modal-content');
            const t = translations[currentLanguage];

            const formatArray = (arr) => arr && arr.length > 0 ? arr.join(', ') : '-';
            const formatSingleOrArray = (val) => {
                if (Array.isArray(val)) return formatArray(val);
                return val || '-';
            };


            modalContent.innerHTML = `
                <h3>${t.modal_title}</h3>
                <table>
                    <tr><th>${t.label_spell_name}</th><td>${spell.name || '-'}</td></tr>
                    <tr><th>${t.label_spell_type}</th><td>${formatSingleOrArray(spell.type)}</td></tr>
                    <tr><th>${t.label_power_set}</th><td>${formatSingleOrArray(spell.powerSet)}</td></tr>
                    <tr><th>${t.label_power_set_tree}</th><td>${formatSingleOrArray(spell.powerSetTree)}</td></tr>
                    <tr><th>${t.label_level}</th><td>${formatSingleOrArray(spell.level)}</td></tr>
                    <tr><th>${t.label_description}</th><td>${spell.description || '-'}</td></tr>
                    <tr><th>${t.label_action}</th><td>${formatSingleOrArray(spell.action)}</td></tr>
                    <tr><th>${t.label_target}</th><td>${formatSingleOrArray(spell.target)}</td></tr>
                    <tr><th>${t.label_range}</th><td>${formatSingleOrArray(spell.range)}</td></tr>
                    <tr><th>${t.label_duration}</th><td>${formatSingleOrArray(spell.duration)}</td></tr>
                    <tr><th>${t.label_effect}</th><td>${spell.effect || '-'}</td></tr>
                    <tr><th>${t.label_cooldown}</th><td>${formatArray(spell.cooldown)}</td></tr>
                    <tr><th>${t.label_cost}</th><td>${formatArray(spell.cost)}</td></tr>
                    <tr><th>${t.label_defense}</th><td>${formatSingleOrArray(spell.defense)}</td></tr>
                    <tr><th>${t.label_attack}</th><td>${formatSingleOrArray(spell.attack)}</td></tr>
                    <tr><th>${t.label_restrictions}</th><td>${formatArray(spell.restrictions)}</td></tr>
                    <tr><th>${t.label_upgrades}</th><td>${formatArray(spell.upgrades)}</td></tr>
                </table>
                <div class="modal-buttons">
                    <button onclick="loadSpell(savedSpells[${index}])">${t.edit_spell}</button>
                    <button onclick="closeModal()">${t.close_modal}</button>
                </div>
            `;
            modal.style.display = 'flex';
        }

        // Confirm delete spell in modal
        function confirmDeleteSpell(index) {
            const modal = document.getElementById('spell-modal');
            const modalContent = document.getElementById('modal-content');
            const t = translations[currentLanguage];
            modalContent.innerHTML = `
                <h3>${t.confirm_delete_title}</h3>
                <p class="confirm-modal">${t.confirm_delete}</p>
                <div class="modal-buttons">
                    <button onclick="deleteSpell(${index})">${t.confirm}</button>
                    <button onclick="closeModal()">${t.cancel}</button>
                </div>
            `;
            modal.style.display = 'flex';
        }
		
		document.addEventListener('mousemove', (e) => {
			const tooltip = document.getElementById('spell-tooltip');
			if (tooltip.style.opacity === '1') {
				tooltip.style.left = `${e.clientX + 20}px`;
				tooltip.style.top = `${e.clientY + 20}px`;
			}
		});

        // Delete spell
        function deleteSpell(index) {
            const row = document.querySelector(`#spell-table-body tr:nth-child(${index + 1})`);
            if (row) {
                row.classList.add('removing');
                setTimeout(() => {
                    savedSpells.splice(index, 1);
                    localStorage.setItem('savedSpells', JSON.stringify(savedSpells));
                    updateSpellList();
                    closeModal();
                }, 300);
            }
        }

        // Close modal
        function closeModal() {
            const modal = document.getElementById('spell-modal');
            const modalContent = document.getElementById('modal-content');
            modalContent.classList.add('closing');
            setTimeout(() => {
                modal.style.display = 'none';
                modalContent.classList.remove('closing');
            }, 300);
        }

        // Update spell list with filtering
		function updateSpellList() {
			const filterName = document.getElementById('filter-name').value.toLowerCase();
			const filterPowerSet = document.getElementById('filter-power-set').value;
			const filterPowerSetTree = document.getElementById('filter-power-set-tree').value;
			const filterType = document.getElementById('filter-type').value;
			const spellTableBody = document.getElementById('spell-table-body');
			spellTableBody.innerHTML = '';

			const filteredSpells = savedSpells.filter(spell => {
			// Ensure spell properties are handled as arrays or single values for filtering
			const spellType = Array.isArray(spell.type) ? spell.type.join(', ').toLowerCase() : (spell.type || '').toLowerCase();
			const spellPowerSet = Array.isArray(spell.powerSet) ? spell.powerSet.join(', ').toLowerCase() : (spell.powerSet || '').toLowerCase();
			const spellPowerSetTree = Array.isArray(spell.powerSetTree) ? spell.powerSetTree.join(', ').toLowerCase() : (spell.powerSetTree || '').toLowerCase();

				return (
					(!filterName || (spell.name && spell.name.toLowerCase().includes(filterName))) &&
					(!filterPowerSet || spellPowerSet.includes(filterPowerSet.toLowerCase())) &&
					(!filterPowerSetTree || spellPowerSetTree.includes(filterPowerSetTree.toLowerCase())) &&
					(!filterType || spellType.includes(filterType.toLowerCase()))
				);
		});

			filteredSpells.forEach((spell, index) => {
				const tr = document.createElement('tr');
        
				// Добавляем обработчики для всплывающей подсказки
				tr.addEventListener('mouseenter', (e) => showSpellTooltip(e, spell));
				tr.addEventListener('mouseleave', hideSpellTooltip);
				tr.addEventListener('mousemove', (e) => {
					const tooltip = document.getElementById('spell-tooltip');
				if (tooltip.style.opacity === '1') {
					tooltip.style.left = `${e.clientX + 20}px`;
					tooltip.style.top = `${e.clientY + 20}px`;
				}
		});

        // Обработчик клика для открытия полных деталей
        tr.onclick = (e) => {
            if (!e.target.classList.contains('delete-btn')) showSpellDetails(spell, index);
        };

        const spellTypeDisplay = Array.isArray(spell.type) ? spell.type.join(', ') : (spell.type || '-');
        const spellPowerSetDisplay = Array.isArray(spell.powerSet) ? spell.powerSet.join(', ') : (spell.powerSet || '-');
        const spellPowerSetTreeDisplay = Array.isArray(spell.powerSetTree) ? spell.powerSetTree.join(', ') : (spell.powerSetTree || '-');
        const spellActionDisplay = Array.isArray(spell.action) ? spell.action.join(', ') : (spell.action || '-');

        tr.innerHTML = `
            <td>${spell.name || '-'}</td>
            <td>${spellPowerSetDisplay}</td>
            <td>${spellPowerSetTreeDisplay}</td>
            <td>${spellTypeDisplay}</td>
            <td>${spellActionDisplay}</td>
            <td><button class="delete-btn" onclick="event.stopPropagation(); confirmDeleteSpell(${index})">${translations[currentLanguage].delete_spell}</button></td>
        `;
        spellTableBody.appendChild(tr);
    });

    updateAutocomplete();
}


        // Autocomplete for filter name
        function updateAutocomplete() {
            const input = document.getElementById('filter-name');
            const autocompleteList = document.getElementById('autocomplete-list');
            const value = input.value.toLowerCase();
            autocompleteList.innerHTML = '';

            if (value.length > 0) {
                const matches = savedSpells
                    .filter(spell => spell.name && spell.name.toLowerCase().includes(value))
                    .slice(0, 5); // Limit to 5 suggestions

                if (matches.length > 0) {
                    autocompleteList.style.display = 'block';
                    matches.forEach(spell => {
                        const div = document.createElement('div');
                        div.className = 'autocomplete-item';
                        div.textContent = spell.name;
                        div.onclick = () => {
                            input.value = spell.name;
                            autocompleteList.style.display = 'none';
                            updateSpellList(); // Update the spell list immediately after selection
                        };
                        autocompleteList.appendChild(div);
                    });
                } else {
                    autocompleteList.style.display = 'none';
                }
            } else {
                autocompleteList.style.display = 'none';
            }
        }
		
function showSpellTooltip(event, spell) {
    const tooltip = document.getElementById('spell-tooltip');
    const t = translations[currentLanguage];
    
    // Новая функция форматирования - убираем двоеточия из значений
    const formatValue = (val) => {
        if (Array.isArray(val)) {
            return val.filter(v => v).join(', ');
        }
        return val || '-';
    };

    tooltip.innerHTML = `
        <h4>${spell.name || '-'}</h4>
        <div class="tooltip-description">
            <div class="tooltip-section">
                <h5>${t.label_description}</h5>
                <p>${spell.description || '-'}</p>
            </div>
            <div class="tooltip-section">
                <h5>${t.label_effect}</h5>
                <p>${spell.effect || '-'}</p>
            </div>
        </div>
        <div class="tooltip-attributes">
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_spell_type}:</span>
                <span class="tooltip-value">${formatValue(spell.type)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_power_set}:</span>
                <span class="tooltip-value">${formatValue(spell.powerSet)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_power_set_tree}:</span>
                <span class="tooltip-value">${formatValue(spell.powerSetTree)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_level}:</span>
                <span class="tooltip-value">${formatValue(spell.level)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_action}:</span>
                <span class="tooltip-value">${formatValue(spell.action)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_target}:</span>
                <span class="tooltip-value">${formatValue(spell.target)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_range}:</span>
                <span class="tooltip-value">${formatValue(spell.range)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_duration}:</span>
                <span class="tooltip-value">${formatValue(spell.duration)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_cooldown}:</span>
                <span class="tooltip-value">${formatValue(spell.cooldown)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_cost}:</span>
                <span class="tooltip-value">${formatValue(spell.cost)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_defense}:</span>
                <span class="tooltip-value">${formatValue(spell.defense)}</span>
            </div>
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_attack}:</span>
                <span class="tooltip-value">${formatValue(spell.attack)}</span>
            </div>
            ${spell.restrictions && spell.restrictions.length > 0 ? `
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_restrictions}:</span>
                <span class="tooltip-value">${formatValue(spell.restrictions)}</span>
            </div>` : ''}
            ${spell.upgrades && spell.upgrades.length > 0 ? `
            <div class="tooltip-attribute">
                <span class="tooltip-label">${t.label_upgrades}:</span>
                <span class="tooltip-value">${formatValue(spell.upgrades)}</span>
            </div>` : ''}
        </div>
    `;
    
    positionTooltip(event, tooltip);
    tooltip.style.opacity = '1';
}

function positionTooltip(event, tooltip) {
    const offset = 10; 
    const x = event.clientX + offset;
    const y = event.clientY + offset;
    const tooltipWidth = tooltip.offsetWidth;
    const tooltipHeight = tooltip.offsetHeight;
    
    // Проверяем, чтобы тултип не выходил за границы экрана
    const adjustedX = x + tooltipWidth > window.innerWidth 
        ? window.innerWidth - tooltipWidth - offset 
        : x;
    
    const adjustedY = y + tooltipHeight > window.innerHeight 
        ? window.innerHeight - tooltipHeight - offset 
        : y;
    
    tooltip.style.left = `${adjustedX}px`;
    tooltip.style.top = `${adjustedY}px`;
}


		function hideSpellTooltip() {
			const tooltip = document.getElementById('spell-tooltip');
			tooltip.style.opacity = '0';
		}

        // Tab switching
        function showTab(tabId) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelector(`.tab[data-tab="${tabId}"]`).classList.add('active');
            localStorage.setItem('activeTab', tabId);
            if (tabId === 'spell-list') {
                // Clear filter inputs when navigating to spell list
                document.getElementById('filter-name').value = '';
                document.getElementById('filter-power-set').value = '';
                document.getElementById('filter-power-set-tree').value = '';
                document.getElementById('filter-type').value = '';
                updateSpellList();
            }
            if (tabId === 'list-manager') showManagedList(); // Ensure manager list updates
        }

        // Show selected list in manager
        function showManagedList() {
            const selectedListElement = document.getElementById('manager-list-type');
            let selectedList = localStorage.getItem('managedListType') || '';

            // If the element has a value from a user click, prioritize it
            if (selectedListElement.value && selectedListElement.value !== selectedList) {
                selectedList = selectedListElement.value;
                localStorage.setItem('managedListType', selectedList);
            } else {
                // Otherwise, set the dropdown to the stored value
                selectedListElement.value = selectedList;
            }


            // Hide all manager sections
            document.querySelectorAll('#list-manager > div[id$="-section"]').forEach(section => {
                section.style.display = 'none';
            });

            // Show and populate the selected section
            if (selectedList) {
                const sectionId = `manager-${selectedList}-section`;
                const section = document.getElementById(sectionId);
                if (section) {
                    section.style.display = 'block';
                    if (selectedList === 'powerSets') {
                        updatePowerSetList();
                        // Set default selected power set for editing if available
                        const powerSetSelectElement = document.getElementById('power-set-select');
                        if (Object.keys(lists.powerSets).length > 0 && (powerSetSelectElement.value === "" || !lists.powerSets[powerSetSelectElement.value])) {
                             powerSetSelectElement.value = Object.keys(lists.powerSets)[0];
                        }
                        loadPowerSetTreeForEdit();
                    } else {
                        updateList(selectedList);
                    }
                }
            }
        }


        // Keyboard navigation and modal handling
        document.addEventListener('keydown', (e) => {
            const tabs = Array.from(document.querySelectorAll('.tab'));
            const activeTab = document.querySelector('.tab.active');
            const activeIndex = tabs.indexOf(activeTab);
            const modal = document.getElementById('spell-modal');

            if (modal.style.display === 'flex' && e.key === 'Escape') {
                closeModal();
            } else if (e.key === 'ArrowRight') {
                const nextIndex = (activeIndex + 1) % tabs.length;
                showTab(tabs[nextIndex].dataset.tab);
            } else if (e.key === 'ArrowLeft') {
                const prevIndex = (activeIndex - 1 + tabs.length) % tabs.length;
                showTab(tabs[prevIndex].dataset.tab);
            } else if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (document.getElementById('spell-creator').classList.contains('active')) saveSpell();
            } else if (e.ctrlKey && e.key === 'l') {
                e.preventDefault();
                if (document.getElementById('spell-creator').classList.contains('active')) loadSpell();
            } else if (e.ctrlKey && e.key === 'r') {
                e.preventDefault();
                if (document.getElementById('spell-creator').classList.contains('active')) clearForm();
            }
        });

        // Close modal on click outside
        document.getElementById('spell-modal').addEventListener('click', (e) => {
            if (e.target === document.getElementById('spell-modal')) closeModal();
        });

        // Initialize when DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            initializeTabs();
            // IMPORTANT: Initialize dynamic inputs before populating dropdowns to ensure elements exist
            initializeDynamicInputs();
            updateLanguage(); // Update language and button texts
            populateDropdowns(); // Populate dropdowns with data
            showTab(localStorage.getItem('activeTab') || 'spell-creator');
            showManagedList(); // Initialize the list manager's display state


            // Filter input event and blur to hide autocomplete
            document.getElementById('filter-name').addEventListener('input', updateSpellList);
            document.getElementById('filter-name').addEventListener('blur', () => {
                // Delay hiding to allow click on autocomplete item
                setTimeout(() => {
                    document.getElementById('autocomplete-list').style.display = 'none';
                }, 200);
            });
            document.getElementById('filter-name').addEventListener('focus', () => {
                // Show autocomplete list on focus if there's already text
                if (document.getElementById('filter-name').value.length > 0) {
                    updateAutocomplete();
                }
            });

            // Attach event listeners for filter dropdowns to update the spell list
            document.getElementById('filter-power-set').addEventListener('change', updateFilterPowerSetTree);
            document.getElementById('filter-power-set-tree').addEventListener('change', updateSpellList);
            document.getElementById('filter-type').addEventListener('change', updateSpellList);

        });
    </script>
    <script src="scripts/particles.js"></script>
    <script src="scripts/powersets.js"></script>
</body>
</html>